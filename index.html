<!DOCTYPE html>

<!--
pdf2xml-viewer - A simple viewer and inspection tool for text boxes in PDF documents

Uses d3.js.

July 2016, Markus Konrad <markus.konrad@wzb.eu> / Berlin Social Science Center (https://www.wzb.eu/en)
-->

<meta charset="utf-8">
<style>
	body {
		font: 10px sans-serif;
        margin: 0;
        padding: 0;
	}

    #main {
        width: 95vw;
        height: 95vh;
        border: 1px solid black;
        overflow: scroll;
        margin-left: auto;
        margin-right: auto;
    }

    #control {
        background: #CCCCCC;
    }

    svg {
        margin: 0;
        padding: 0;
    }

    rect {
        fill: none;
        stroke: red;
    }

    text {
        stroke: black;
    }

    .lines {
        stroke: blue;
    }

    .grid-row rect {
        stroke: brown;
        fill-opacity: 0.33;
        stroke-opacity: 0.25;
        stroke-width: 1px;
    }

    .grid-row.even rect {
        fill: #FF9933;
    }
    .grid-row.odd rect {
        fill: #FFFF33;
    }
</style>
<body>

<script src="d3.js" charset="utf-8"></script>

<script>
    var xmldoc = null;
    var svg = null;
    var curPageIndex = 0;      // page offset 0 .. N_PAGES
    var curPageNumber = null;  // number defined in "page" elements of XML file (does not have to start with 1!)
    var pages = null;
    var pageNumbers = [];    // array as page index -> page number
    var fontspecs = {};  // are global for all pages
    var pagesGrids = null;
    var grid = null;
    var alwaysDisplayGrid = false;

    function displayPage(p) {
        var w = p.attributes['width'].value;
        var h = p.attributes['height'].value;

        function textStyle(textNode, prop) {
            var spec = fontspecs[textNode.attributes['font'].value];
            return spec[prop];
        }

        if (svg != null) {
            svg.remove();
        }

        svg = d3.select("#main").append("svg")
                .attr("width", w)
                .attr("height", h);

        var textNodes = p.getElementsByTagName('text');

        var textGroups = svg.selectAll('.text')
                .data(textNodes).enter()
                .append('g')
                .attr('class', 'text')
                .attr('transform', function (d) {
                    var x = d.attributes['left'].value;
                    var y = d.attributes['top'].value;
                    return 'translate(' + x + ', ' + y + ')';
                });

        var textRects = textGroups.append('rect')
                .attr('width', function (d) { return d.attributes['width'].value; })
                .attr('height', function (d) { return d.attributes['height'].value; });
        var textInRects = textGroups.append('text')
                .attr('dy', function (d) { return d.attributes['height'].value / 1.4; })
                .style('font-size', function (d) { return textStyle(d, 'size') })
                .style('font-family', function (d) { return textStyle(d, 'family') })
                .style('font-weight', function (d) {
                    if (d.childNodes.length == 1 && d.childNodes[0].innerHTML && d.childNodes[0].tagName == 'b') {
                        return 'bold';
                    } else {
                        return 'normal';
                    }
                })
                .style('font-style', function (d) {
                    if (d.childNodes.length == 1 && d.childNodes[0].innerHTML && d.childNodes[0].tagName == 'i') {
                        return 'italic';
                    } else {
                        return 'normal';
                    }
                })
                .text(function (d) {
                    var txt = '';
                    for (var i = 0; i < d.childNodes.length; i++) {
                        var child = d.childNodes[i];
                        if (child.innerHTML) {
                            txt += ' ' + child.innerHTML;
                        } else {
                            txt += ' ' + child.nodeValue;
                        }
                    }
                    
                    return txt;
                });

        if (alwaysDisplayGrid) {
            displayGrid();
        }
    }

    function loadXMLFile(xmlfile) {
        xmlfile = typeof xmlfile !== 'undefined' ? xmlfile : document.getElementById('xmlfile').value;


        if (xmlfile.match(/^\W/) || xmlfile.match(/^(http|https|file):/)) {
            return;
        }

        console.log("loading XML file '" + xmlfile + "'");
        d3.xml(xmlfile, 'application/xml', function (d) {
            xmldoc = d;

            pages = xmldoc.getElementsByTagName('page');

            if (pages.length <= 0) return;
            
            for (var i = 0; i < pages.length; i++) {
              pageNumbers[i] = parseInt(pages[i].attributes.number.value);
            }

            loadFontSpecs(pages);

            document.getElementById('pagenum').disabled = false;
            document.getElementById('pagemax').innerHTML = pageNumbers[pageNumbers.length - 1];

            setPageIndex(0);
        });
    }

    function loadFontSpecs(pages) {
        for (var p_i = 0; p_i < pages.length; p_i++) {
            var p = pages[p_i];
            var fontspecElems = p.getElementsByTagName('fontspec');
            for (var i = 0; i < fontspecElems.length; i++) {
                var spec = fontspecElems[i].attributes;
                fontspecs[spec.id.value] = {
                    'size': spec.size.value,
                    'family': spec.family.value
                }
            }

        }
    }

    function setPageIndex(index) {
        if (index == null) {
           index = 0;
        }
        
        if (index < 0 || index >= pageNumbers.length) {
            return;
        }
        
        curPageIndex = index;
        curPageNumber = pageNumbers[curPageIndex];
        
        document.getElementById('pagenum').value = curPageNumber;

        displayPage(pages[curPageIndex]);
    }
    
    function setPageNumber() {
        var num = parseInt(document.getElementById('pagenum').value);
        var index = pageNumbers.indexOf(num);
        
        if (index >= 0) {
            setPageIndex(index);
        }
    }

    function changePage(by) {
        var toPageIndex = curPageIndex + by;
        if (toPageIndex >= 0 && toPageIndex < pageNumbers.length) {
            setPageIndex(toPageIndex);
        }
    }

    function loadGridFile(gridfile) {
        d3.json(gridfile, function (d) {
            pagesGrids = d;
        });
    }

    function displayGrid() {
        if (!pagesGrids || !(curPageNumber in pagesGrids)) {
            console.log('pages grids not loaded or this page does not have a grid');
            return;
        }

        grid = pagesGrids[curPageNumber];

        var gridRows = svg.selectAll('.grid-row')
                .data(grid).enter()
                .append('g')
                .attr('class', function (d, i) {
                    var evenodd = i % 2 == 0 ? 'even' : 'odd';
                    return 'grid-row ' + evenodd
                });

        var gridCells = gridRows.selectAll('.grid-cell')
                .data(function (d) { return d}).enter()
                .append('g')
                .attr('class', function (d, i) {
                    var evenodd = i % 2 == 0 ? 'even' : 'odd';
                    return 'grid-cell ' + evenodd
                })
                .attr('transform', function (d) {
                    var x = d[0][0];
                    var y = d[0][1];
                    return 'translate(' + x + ', ' + y + ')';
                });
        var gridRects = gridCells.selectAll('rect')
                .data(function (d) { return [d]}).enter()
                .append('rect')
                .attr('width', function (d) { return  d[1][0] - d[0][0]; })
                .attr('height', function (d) { return  d[1][1] - d[0][1]; });
    }

    function removeGrid() {
        d3.selectAll('.grid-cell').remove();
    }

    function drawLines(positions, direction) {
        var p = pages[curPageNumber];
        var w = parseInt(p.attributes['width'].value);
        var h = parseInt(p.attributes['height'].value);

        var coord, maxpos;

        if (direction == 'x') {
            coord = 1;
            maxpos = w;
        } else if (direction == 'y') {
            coord = 0;
            maxpos = h;
        } else {
            console.error('invalid direction:', direction);
            return;
        }

        var linesGroup = svg.append("g").attr("class", "lines");

        var othercoord = (coord + 1) % 2;

        var line = d3.svg.line()
                .x(function (d) { return d[0] })
                .y(function (d) { return d[1] })
                .interpolate("basis");

        positions.forEach(function (pos) {
            var from = [null, null];
            var to = [null, null];
            from[coord] = pos;
            from[othercoord] = 0;
            to[coord] = pos;
            to[othercoord] = maxpos;

            linesGroup.append('path').attr('d', line([from, to]))
        });
    }

    function removeLines() {
        d3.selectAll('.lines').remove();
    }
</script>

<div id="control">
    <fieldset>
        <label for="xmlfile">XML File:</label>
        <input id="xmlfile" name="xmlfile" type="text" required autofocus>
        <input type="submit" value="Load" onclick="loadXMLFile()" style="margin-right: 5em">

        <label for="pagenum">Page:</label>
        <button onclick="changePage(-1)">&larr;</button>
        <input id="pagenum" name="pagenum" type="number" onchange="setPageNumber()" size="4" style="width: 40px" disabled> / <span id="pagemax">?</span>
        <button onclick="changePage(+1)">&rarr;</button>
    </fieldset>
</div>

<div id="main">

</div>

</body>
